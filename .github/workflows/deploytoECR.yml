name: Build, Push to ECR, and Trigger ArgoCD Chart Update

on:
  workflow_dispatch: # Allows manual triggering
  push:
    branches:
      - main # Or your default branch, triggers on push to this branch

permissions:
  contents: read    # To checkout the repo
  id-token: write   # Required for aws-actions/configure-aws-credentials if using OIDC role-based auth
  actions: write    # To dispatch repository events (if CHARTS_REPO_TOKEN is scoped for this)

env:
  # Secrets must be configured in GitHub repository settings
  AWS_REGION: ${{ secrets.TF_REGION }}
  ECR_REPOSITORY_NAME: ${{ secrets.TF_ECR_NAME }} # Just the name, e.g., "proyectofinallsjecr"
  TAG_VERSION: ${{ github.run_number }} # Uses the workflow run number as a version

jobs:
  build-and-push:
    runs-on: ubuntu-22.04
    outputs:
      # This output will be used by the trigger-chart-update job
      ecr_registry_uri: ${{ steps.login-ecr.outputs.registry }}

    steps:
    - name: Checkout Microservices Repository
      uses: actions/checkout@v4

    - name: Set up AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }} # Optional: if using temporary credentials
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr # Step ID to reference its outputs
      uses: aws-actions/amazon-ecr-login@v2

    - name: Set up JDK 17
      uses: actions/setup-java@v4
      with:
        distribution: 'temurin'
        java-version: '17'

    - name: Build with Maven
      run: ./mvnw clean package -DskipTests # Skipping tests for CI speed; adjust as needed

    - name: Create single ECR repository if it doesn't exist
      run: |
        echo "Checking/Creating ECR repository: ${{ env.ECR_REPOSITORY_NAME }} in region ${{ env.AWS_REGION }}"
        aws ecr describe-repositories --repository-names ${{ env.ECR_REPOSITORY_NAME }} --region ${{ env.AWS_REGION }} > /dev/null 2>&1 || \
        aws ecr create-repository \
          --repository-name ${{ env.ECR_REPOSITORY_NAME }} \
          --region ${{ env.AWS_REGION }} \
          --image-tag-mutability MUTABLE \
          --image-scanning-configuration scanOnPush=true # Optional: enable image scanning
        echo "ECR repository check/creation complete."

    - name: Build and Push Docker Images to Single ECR Repository
      run: |
        ECR_REGISTRY_URI="${{ steps.login-ecr.outputs.registry }}" # Get ECR registry from login step output
        echo "ECR Registry URI: $ECR_REGISTRY_URI"
        echo "ECR Repository Name: ${{ env.ECR_REPOSITORY_NAME }}"

        # List all your microservice directory names that contain Dockerfiles
        services=(
          cloud-config
          service-discovery
          api-gateway
          proxy-client
          # frontend # Uncomment if frontend is built as a Docker image here
          order-service
          payment-service
          product-service
          shipping-service
          user-service
          favourite-service
        )

        for service_dir_name in "${services[@]}"; do
          echo "Processing service: $service_dir_name"
          
          # Assuming Dockerfile is at the root of each service's directory (e.g., cloud-config/Dockerfile)
          # And the context for the build is that service's directory.
          CONTEXT_PATH="./${service_dir_name}"
          DOCKERFILE_PATH="${CONTEXT_PATH}/Dockerfile"

          if [ ! -f "$DOCKERFILE_PATH" ]; then
            echo "Warning: Dockerfile not found at $DOCKERFILE_PATH. Skipping $service_dir_name."
            continue
          fi
          
          # Image tags will be like: ECR_URI/proyectofinallsjecr:cloud-config-123
          IMAGE_TAG_VERSIONED="$ECR_REGISTRY_URI/${{ env.ECR_REPOSITORY_NAME }}:$service_dir_name-${{ env.TAG_VERSION }}"
          IMAGE_TAG_LATEST="$ECR_REGISTRY_URI/${{ env.ECR_REPOSITORY_NAME }}:$service_dir_name-latest"
          
          echo "Building image: $IMAGE_TAG_VERSIONED from context $CONTEXT_PATH using $DOCKERFILE_PATH"
          docker build -t "$IMAGE_TAG_VERSIONED" -f "$DOCKERFILE_PATH" "$CONTEXT_PATH"
          
          echo "Tagging image as latest: $IMAGE_TAG_LATEST"
          docker tag "$IMAGE_TAG_VERSIONED" "$IMAGE_TAG_LATEST"
          
          echo "Pushing versioned tag: $IMAGE_TAG_VERSIONED"
          docker push "$IMAGE_TAG_VERSIONED"
          
          echo "Pushing latest tag: $IMAGE_TAG_LATEST"
          docker push "$IMAGE_TAG_LATEST"
          echo "Finished processing $service_dir_name."
        done

  trigger-chart-update:
    needs: build-and-push # Ensures build-and-push completes first and its outputs are available
    runs-on: ubuntu-22.04
    
    steps:
    - name: Checkout Microservices Repository (for git log)
      uses: actions/checkout@v4
      with:
        fetch-depth: 20 # Fetch enough history for release notes; 0 for all.

    - name: Debug ECR URI from build-and-push job
      run: echo "Received ECR Registry URI from previous job: ${{ needs.build-and-push.outputs.ecr_registry_uri }}"

    - name: Trigger chart repository update
      uses: actions/github-script@v7
      with:
        # This token (PAT) needs 'repo' scope if ecommerce-chart is private,
        # or rights to trigger repository_dispatch events on microservices-project-k8s-jenkins/ecommerce-chart.
        github-token: ${{ secrets.CHARTS_REPO_TOKEN }}
        script: |
          const source_branch = '${{ github.ref_name }}'; // Branch of this microservices repo
          const base_version_tag = '${{ env.TAG_VERSION }}'; // e.g., "7" (from github.run_number)
          const ecr_registry_uri = '${{ needs.build-and-push.outputs.ecr_registry_uri }}';
          const ecr_repository_name = '${{ env.ECR_REPOSITORY_NAME }}'; // e.g., "proyectofinallsjecr"

          console.log(`Source Branch: ${source_branch}`);
          console.log(`Base Version Tag: ${base_version_tag}`);
          console.log(`ECR Registry URI: ${ecr_registry_uri}`);
          console.log(`ECR Repository Name: ${ecr_repository_name}`);

          if (!ecr_registry_uri || ecr_registry_uri.trim() === "") {
            core.setFailed('Critical Error: ecr_registry_uri is empty. Cannot dispatch event.');
            return;
          }
          if (!ecr_repository_name || ecr_repository_name.trim() === "") {
            core.setFailed('Critical Error: ecr_repository_name is empty. Cannot dispatch event.');
            return;
          }

          const services_to_update = [
            'cloud-config', 'service-discovery', 'api-gateway', 'proxy-client',
            // 'frontend', 
            'order-service', 'payment-service', 'product-service', 
            'shipping-service', 'user-service', 'favourite-service'
          ];
          
          const owner = 'microservices-project-k8s-jenkins'; // Owner of ecommerce-chart repo
          const repo = 'ecommerce-chart';                   // Name of ecommerce-chart repo
          
          console.log(`Dispatching 'update-image-tags' event to ${owner}/${repo}`);
          await github.rest.repos.createDispatchEvent({
            owner: owner,
            repo: repo,
            event_type: 'update-image-tags', // This type must be handled by a workflow in ecommerce-chart
            client_payload: {
              source_branch: source_branch,
              base_version_tag: base_version_tag,
              ecr_registry_uri: ecr_registry_uri,
              ecr_repository_name: ecr_repository_name,
              services_to_update: services_to_update
            }
          });
          
          console.log(`Successfully triggered chart update for services with base version tag ${base_version_tag}.`);

    - name: Generate Release Notes
      run: |
        echo "Generating release notes..."
        git log -n 20 --pretty=format:"* %h %s (%an, %ar)" > release-notes.md
        echo "Content of release-notes.md:"
        cat release-notes.md

    - name: Upload Release Notes
      if: success() && hashFiles('release-notes.md') != ''
      uses: actions/upload-artifact@v4
      with:
        name: release-notes-${{ env.TAG_VERSION }}
        path: release-notes.md

    - name: Deployment Summary
      run: |
        echo "## Deployment Summary" >> $GITHUB_STEP_SUMMARY
        echo "- **Source Branch:** ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Base Image Version Tag:** ${{ env.TAG_VERSION }}" >> $GITHUB_STEP_SUMMARY
        echo "- **ECR Registry URI:** ${{ needs.build-and-push.outputs.ecr_registry_uri }}" >> $GITHUB_STEP_SUMMARY
        echo "- **ECR Repository Name:** ${{ env.ECR_REPOSITORY_NAME }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Target Chart Repository for Update Event:** microservices-project-k8s-jenkins/ecommerce-chart" >> $GITHUB_STEP_SUMMARY
        echo "- **ArgoCD will sync changes after the chart repository is updated by its own workflow.**" >> $GITHUB_STEP_SUMMARY
