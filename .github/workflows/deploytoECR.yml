name: Build, Push to ECR, and Trigger Chart Update (Single Job, Multi-Branch)

on:
  workflow_dispatch: # Permite disparo manual
  pull_request:
    types:
      - closed
    branches:
      - master
      - stage
      - dev

permissions:
  contents: read
  id-token: write

env:
  AWS_REGION: ${{ secrets.TF_REGION }}
  ECR_REPOSITORY_NAME: ${{ secrets.TF_ECR_NAME }}
  # TAG_VERSION se determinará dinámicamente ahora

jobs:
  build-push-and-trigger:
    runs-on: ubuntu-22.04
    steps:
    - name: Checkout Microservices Repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 20

    - name: Determine Target Environment and Tag Version
      id: set-env-details
      run: |
        BRANCH_NAME="${{ github.ref_name }}"
        echo "Workflow triggered by ref: ${{ github.ref }}, branch_name: $BRANCH_NAME"
        
        TARGET_VALUES_FILE=""
        TAG_PREFIX=""

        if [[ "$BRANCH_NAME" == "main" || "$BRANCH_NAME" == "master" ]]; then
          TARGET_VALUES_FILE="values-master.yaml"
          TAG_PREFIX="prod"
        elif [[ "$BRANCH_NAME" == "stage" ]]; then
          TARGET_VALUES_FILE="values-stage.yaml"
          TAG_PREFIX="stage"
        elif [[ "$BRANCH_NAME" == "dev" ]]; then
          TARGET_VALUES_FILE="values-dev.yaml"
          TAG_PREFIX="dev"
        elif [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
          # Para disparos manuales, podríamos pedir inputs o usar un default.
          # Asumamos que el disparo manual por defecto es para 'dev' o un tag genérico.
          # O podrías añadir inputs al workflow_dispatch para especificar esto.
          # Por ahora, si es manual, no estableceremos un TAG_PREFIX específico basado en rama.
          echo "Manual workflow_dispatch triggered. Using default/generic tagging."
          TARGET_VALUES_FILE="values-dev.yaml" # O el que prefieras para manual
          TAG_PREFIX="manual" # O un prefijo que indique un build manual
        else
          echo "::warning::Branch '$BRANCH_NAME' is not configured for specific values file. Using default."
          TARGET_VALUES_FILE="values-dev.yaml" # Un default seguro
          TAG_PREFIX="feature" # O algún otro prefijo
        fi

        # Usar el run_number para todos los casos para unicidad del tag de imagen
        # El TAG_PREFIX es más para la lógica del chart o para diferenciar builds
        FINAL_TAG_VERSION="${{ github.run_number }}"

        echo "TARGET_VALUES_FILE_ENV=$TARGET_VALUES_FILE" >> $GITHUB_ENV
        echo "TAG_VERSION_ENV=$FINAL_TAG_VERSION" >> $GITHUB_ENV
        echo "BRANCH_NAME_ENV=$BRANCH_NAME" >> $GITHUB_ENV # Pasar la rama original
        echo "TAG_PREFIX_ENV=$TAG_PREFIX" >> $GITHUB_ENV

        echo "Target values file determined: $TARGET_VALUES_FILE"
        echo "Tag version determined: $FINAL_TAG_VERSION"
        echo "Branch name: $BRANCH_NAME"
        echo "Tag prefix: $TAG_PREFIX"

    # ... (Set up AWS credentials, DEBUG AWS Account ID, Login to ECR, Determine ECR URI and Set as Env Var - SIN CAMBIOS) ...
    # Todos estos steps se mantienen igual que en tu última versión funcional del workflow de un solo job.
    # Los voy a omitir aquí por brevedad, pero deben estar presentes.

    - name: Set up AWS credentials
      id: aws-creds 
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }} 
        aws-region: ${{ env.AWS_REGION }}
        mask-aws-account-id: 'no' 

    - name: DEBUG - AWS Account ID from aws-creds (if available)
      run: |
        echo "AWS Account ID from aws-creds step: ${{ steps.aws-creds.outputs.aws-account-id }}"

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Determine ECR Registry URI and Set as Env Var
      id: set-ecr-uri
      run: |
        ECR_URI_FROM_LOGIN="${{ steps.login-ecr.outputs.registry }}"
        AWS_ACCOUNT_ID_CLI=$(aws sts get-caller-identity --query Account --output text)
        AWS_REGION_ENV="${{ env.AWS_REGION }}"
        FINAL_ECR_URI=""
        if [ -n "$ECR_URI_FROM_LOGIN" ]; then
          FINAL_ECR_URI="$ECR_URI_FROM_LOGIN"
        elif [ -n "$AWS_ACCOUNT_ID_CLI" ] && [ "$AWS_ACCOUNT_ID_CLI" != "None" ] && [ -n "$AWS_REGION_ENV" ]; then
          FINAL_ECR_URI="${AWS_ACCOUNT_ID_CLI}.dkr.ecr.${AWS_REGION_ENV}.amazonaws.com"
        fi
        if [ -z "$FINAL_ECR_URI" ]; then exit 1; fi
        echo "ECR_REGISTRY_URI_ENV=$FINAL_ECR_URI" >> $GITHUB_ENV
        echo "registry_uri_output=$FINAL_ECR_URI" >> $GITHUB_OUTPUT

    - name: DEBUG - ECR URI for subsequent steps
      run: |
        echo "ECR URI from GITHUB_ENV: ${{ env.ECR_REGISTRY_URI_ENV }}"
        echo "ECR URI from step output: ${{ steps.set-ecr-uri.outputs.registry_uri_output }}"

    - name: Set up JDK 17
      uses: actions/setup-java@v4
      with:
        distribution: 'temurin'
        java-version: '17'

    - name: Build with Maven
      run: ./mvnw clean package -DskipTests

    - name: Create single ECR repository if it doesn't exist
      run: |
        aws ecr describe-repositories --repository-names ${{ env.ECR_REPOSITORY_NAME }} --region ${{ env.AWS_REGION }} > /dev/null 2>&1 || \
        aws ecr create-repository --repository-name ${{ env.ECR_REPOSITORY_NAME }} --region ${{ env.AWS_REGION }} --image-tag-mutability MUTABLE --image-scanning-configuration scanOnPush=true

    - name: Build and Push Docker Images to Single ECR Repository
      env:
        ECR_REGISTRY_URI_FOR_DOCKER: ${{ env.ECR_REGISTRY_URI_ENV }}
        TAG_VERSION_FOR_DOCKER: ${{ env.TAG_VERSION_ENV }} # Usar la variable de entorno
      run: |
        # ... (la lógica de build y push se mantiene igual, pero usa TAG_VERSION_FOR_DOCKER)
        # Ejemplo de cambio para el tag de la imagen:
        # IMAGE_TAG_VERSIONED="$ECR_REGISTRY_URI_FOR_DOCKER/${{ env.ECR_REPOSITORY_NAME }}:$service_dir_name-${TAG_VERSION_FOR_DOCKER}"
        # ...
        if [ -z "$ECR_REGISTRY_URI_FOR_DOCKER" ]; then exit 1; fi
        services=( cloud-config service-discovery api-gateway proxy-client order-service payment-service product-service shipping-service user-service favourite-service )
        for service_dir_name in "${services[@]}"; do
          CONTEXT_PATH="./${service_dir_name}"; DOCKERFILE_PATH="${CONTEXT_PATH}/Dockerfile"
          if [ ! -f "$DOCKERFILE_PATH" ]; then continue; fi
          IMAGE_TAG_VERSIONED="$ECR_REGISTRY_URI_FOR_DOCKER/${{ env.ECR_REPOSITORY_NAME }}:$service_dir_name-${TAG_VERSION_FOR_DOCKER}" # Usa TAG_VERSION_FOR_DOCKER
          IMAGE_TAG_LATEST="$ECR_REGISTRY_URI_FOR_DOCKER/${{ env.ECR_REPOSITORY_NAME }}:$service_dir_name-latest"
          docker build -t "$IMAGE_TAG_VERSIONED" -f "$DOCKERFILE_PATH" "$CONTEXT_PATH"
          docker tag "$IMAGE_TAG_VERSIONED" "$IMAGE_TAG_LATEST"
          docker push "$IMAGE_TAG_VERSIONED"; docker push "$IMAGE_TAG_LATEST"
        done

    - name: Trigger chart repository update
      env:
        SCRIPT_ECR_REGISTRY_URI: ${{ env.ECR_REGISTRY_URI_ENV }}
        SCRIPT_TARGET_VALUES_FILE: ${{ env.TARGET_VALUES_FILE_ENV }}
        SCRIPT_BRANCH_NAME: ${{ env.BRANCH_NAME_ENV }}
        SCRIPT_TAG_VERSION: ${{ env.TAG_VERSION_ENV }}
      uses: actions/github-script@v7
      with:
        github-token: ${{ secrets.CHARTS_REPO_TOKEN }}
        script: |
          const source_branch_name = process.env.SCRIPT_BRANCH_NAME; // La rama original que disparó
          const base_version_tag = process.env.SCRIPT_TAG_VERSION;
          const ecr_registry_uri = process.env.SCRIPT_ECR_REGISTRY_URI;
          const ecr_repository_name = '${{ env.ECR_REPOSITORY_NAME }}';
          const target_values_file_in_chart = process.env.SCRIPT_TARGET_VALUES_FILE; // e.g., "values-dev.yaml"

          console.log(`Source Branch (Triggering Branch): ${source_branch_name}`);
          console.log(`Base Version Tag: ${base_version_tag}`);
          console.log(`ECR Registry URI: ${ecr_registry_uri}`);
          console.log(`ECR Repository Name: ${ecr_repository_name}`);
          console.log(`Target Values File in Chart Repo: ${target_values_file_in_chart}`);

          if (!ecr_registry_uri || ecr_registry_uri.trim() === "" || !target_values_file_in_chart) {
            core.setFailed('Critical Error: ECR URI or Target Values File is empty. Cannot dispatch event.');
            return;
          }

          const services_to_update = [ /* tu lista de servicios */ ];
          // ... (lista de servicios igual que antes)
          // services_to_update = ['cloud-config', 'service-discovery', ...];
          
          const owner = 'microservices-project-k8s-jenkins';
          const repo = 'ecommerce-chart';                   
          
          await github.rest.repos.createDispatchEvent({
            owner: owner, repo: repo, event_type: 'update-image-tags',
            client_payload: {
              source_branch_name: source_branch_name, // Rama original que disparó el workflow
              base_version_tag: base_version_tag,
              ecr_registry_uri: ecr_registry_uri, 
              ecr_repository_name: ecr_repository_name,
              services_to_update: ['cloud-config', 'service-discovery', 'api-gateway', 'proxy-client', 'order-service', 'payment-service', 'product-service', 'shipping-service', 'user-service', 'favourite-service'],
              target_values_file: target_values_file_in_chart // Nuevo: pasar el nombre del archivo de values
            }
          });
          console.log(`Successfully triggered chart update for ${target_values_file_in_chart}.`);

    - name: Generate Release Notes
      env:
        TAG_VERSION_FOR_NOTES: ${{ env.TAG_VERSION_ENV }}
      run: |
        git log -n 20 --pretty=format:"* %h %s (%an, %ar)" > release-notes-${TAG_VERSION_FOR_NOTES}.md
        cat release-notes-${TAG_VERSION_FOR_NOTES}.md

    - name: Upload Release Notes
      if: success()
      uses: actions/upload-artifact@v4
      with:
        name: release-notes-${{ env.TAG_VERSION_ENV }}
        path: release-notes-${{ env.TAG_VERSION_ENV }}.md # Asegúrate que el path coincida

    - name: Deployment Summary
      env:
        SUMMARY_ECR_REGISTRY_URI: ${{ env.ECR_REGISTRY_URI_ENV }}
        SUMMARY_TAG_VERSION: ${{ env.TAG_VERSION_ENV }}
        SUMMARY_TARGET_VALUES_FILE: ${{ env.TARGET_VALUES_FILE_ENV }}
        SUMMARY_BRANCH_NAME: ${{ env.BRANCH_NAME_ENV }}
      run: |
        echo "## Deployment Summary for Branch: ${SUMMARY_BRANCH_NAME}" >> $GITHUB_STEP_SUMMARY
        echo "- **Target Values File Updated:** ${SUMMARY_TARGET_VALUES_FILE}" >> $GITHUB_STEP_SUMMARY
        # ... (resto del resumen igual que antes, pero usando las nuevas variables de entorno)
        echo "- **Base Image Version Tag:** ${SUMMARY_TAG_VERSION}" >> $GITHUB_STEP_SUMMARY
        echo "- **ECR Registry URI:** ${SUMMARY_ECR_REGISTRY_URI}" >> $GITHUB_STEP_SUMMARY
        echo "- **ECR Repository Name:** ${{ env.ECR_REPOSITORY_NAME }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Target Chart Repository for Update Event:** microservices-project-k8s-jenkins/ecommerce-chart" >> $GITHUB_STEP_SUMMARY
